package main

import (
	"fmt"
	"go/parser"
	"go/token"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestParse(t *testing.T) {
	testFileSrc := `package foo

	import name "github.com/scottkgregory/name"

	type X interface {
		Flavour() string
	}

	type Y interface {
		X
		Name() name.Name
		YYY(x int, y string, b bool) (int, error)
		ZZZ(x *int) (int, error)
		AAAA(x *int) (length *int, err error)
		BBBB(x map[string]*int) (length *int, err error)
		CCCC(x []name.Name) (length *int, err error)
		DDDD(x ...name.Name) (length *int, err error)
		EEEE(x func(y int, z string) error) (length *int, err error)
	}
	`

	expectedData := &TemplateData{
		Package: "foo",
		Interfaces: []*Interface{
			{
				Name:     "X",
				MockName: "",
				Funcs: []*Func{
					{
						Name: "Flavour",
						Return: []*Param{
							{Name: "", Type: "string"},
						},
					},
				},
			},
			{
				Name:     "Y",
				MockName: "",
				Funcs: []*Func{
					{
						Name: "Name",
						Return: []*Param{
							{Name: "", Type: "name.Name"},
						},
					},
					{
						Name: "YYY",
						Params: []*Param{
							{Name: "x", Type: "int"},
							{Name: "y", Type: "string"},
							{Name: "b", Type: "bool"},
						},
						Return: []*Param{
							{Name: "", Type: "int"},
							{Name: "", Type: "error"},
						},
					},
					{
						Name: "ZZZ",
						Params: []*Param{
							{Name: "x", Type: "*int"},
						},
						Return: []*Param{
							{Name: "", Type: "int"},
							{Name: "", Type: "error"},
						},
					},
					{
						Name: "AAAA",
						Params: []*Param{
							{Name: "x", Type: "*int"},
						},
						Return: []*Param{
							{Name: "length", Type: "*int"},
							{Name: "err", Type: "error"},
						},
					},
					{
						Name: "BBBB",
						Params: []*Param{
							{Name: "x", Type: "map[string]*int"},
						},
						Return: []*Param{
							{Name: "length", Type: "*int"},
							{Name: "err", Type: "error"},
						},
					},
					{
						Name: "CCCC",
						Params: []*Param{
							{Name: "x", Type: "[]name.Name"},
						},
						Return: []*Param{
							{Name: "length", Type: "*int"},
							{Name: "err", Type: "error"},
						},
					},
					{
						Name: "DDDD",
						Params: []*Param{
							{Name: "x", Type: "...name.Name"},
						},
						Return: []*Param{
							{Name: "length", Type: "*int"},
							{Name: "err", Type: "error"},
						},
					},
					{
						Name: "EEEE",
						Params: []*Param{
							{Name: "x", Type: "func(int, string) error"},
						},
						Return: []*Param{
							{Name: "length", Type: "*int"},
							{Name: "err", Type: "error"},
						},
					},
				},
				Embedded: []string{"MockX"},
			},
		},
		Imports: []string{"name \"github.com/scottkgregory/name\""},
		Header:  false,
	}

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "", testFileSrc, parser.ParseComments)
	if err != nil {
		fmt.Printf("error: parsing file: %s\n", err)
		return
	}

	templateData := Parse(f)
	assert.Equal(t, expectedData, templateData)

	templateData.Header = true
	expectedFile := `// Code generated by 'ridicule' DO NOT EDIT.
//
// ######   #####     ######   #####  #######    ####### ######  ####### #######
// ####### #######    ####### ####### #######    ####### ####### ####### #######
// ### ### ### ###    ### ### ### ###   ###      ###     ### ###   ###     ###
// ### ### ### ###    ### ### ### ###   ###      ####### ### ###   ###     ###
// ### ### ### ###    ### ### ### ###   ###      ###     ### ###   ###     ###
// ####### #######    ### ### #######   ###      ####### ####### #######   ###
// ######   #####     ### ###  #####    ###      ####### ######  #######   ###
//
// *** DO NOT EDIT *** This file was generated by 'ridicule' *** DO NOT EDIT ***

package foo

import (
	name "github.com/scottkgregory/name"
	"github.com/stretchr/testify/mock"
)

// MockX mocks the X interface
type MockX struct {
	mock.Mock
}

// MockY mocks the Y interface
type MockY struct {
	mock.Mock
	MockX
}

var _ X = &MockX{}
var _ Y = &MockY{}

// Flavour mocks the Flavour function
func (mock *MockX) Flavour() (r0 string) {
	args := mock.Called()

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(string)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected string")
		}
	}
	return r0
}

// Name mocks the Name function
func (mock *MockY) Name() (r0 name.Name) {
	args := mock.Called()

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(name.Name)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected name.Name")
		}
	}
	return r0
}

// YYY mocks the YYY function
func (mock *MockY) YYY(x int, y string, b bool) (r0 int, r1 error) {
	args := mock.Called(x, y, b)

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(int)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected int")
		}
	}

	if args.Get(1) != nil {
		argOk := false
		r1, argOk = args.Get(1).(error)
		if !argOk {
			panic("incorrect type supplied for return value [1], expected error")
		}
	}
	return r0, r1
}

// ZZZ mocks the ZZZ function
func (mock *MockY) ZZZ(x *int) (r0 int, r1 error) {
	args := mock.Called(x)

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(int)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected int")
		}
	}

	if args.Get(1) != nil {
		argOk := false
		r1, argOk = args.Get(1).(error)
		if !argOk {
			panic("incorrect type supplied for return value [1], expected error")
		}
	}
	return r0, r1
}

// AAAA mocks the AAAA function
func (mock *MockY) AAAA(x *int) (r0 *int, r1 error) {
	args := mock.Called(x)

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(*int)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected *int")
		}
	}

	if args.Get(1) != nil {
		argOk := false
		r1, argOk = args.Get(1).(error)
		if !argOk {
			panic("incorrect type supplied for return value [1], expected error")
		}
	}
	return r0, r1
}

// BBBB mocks the BBBB function
func (mock *MockY) BBBB(x map[string]*int) (r0 *int, r1 error) {
	args := mock.Called(x)

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(*int)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected *int")
		}
	}

	if args.Get(1) != nil {
		argOk := false
		r1, argOk = args.Get(1).(error)
		if !argOk {
			panic("incorrect type supplied for return value [1], expected error")
		}
	}
	return r0, r1
}

// CCCC mocks the CCCC function
func (mock *MockY) CCCC(x []name.Name) (r0 *int, r1 error) {
	args := mock.Called(x)

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(*int)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected *int")
		}
	}

	if args.Get(1) != nil {
		argOk := false
		r1, argOk = args.Get(1).(error)
		if !argOk {
			panic("incorrect type supplied for return value [1], expected error")
		}
	}
	return r0, r1
}

// DDDD mocks the DDDD function
func (mock *MockY) DDDD(x ...name.Name) (r0 *int, r1 error) {
	args := mock.Called(x)

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(*int)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected *int")
		}
	}

	if args.Get(1) != nil {
		argOk := false
		r1, argOk = args.Get(1).(error)
		if !argOk {
			panic("incorrect type supplied for return value [1], expected error")
		}
	}
	return r0, r1
}

// EEEE mocks the EEEE function
func (mock *MockY) EEEE(x func(int, string) error) (r0 *int, r1 error) {
	args := mock.Called(x)

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(*int)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected *int")
		}
	}

	if args.Get(1) != nil {
		argOk := false
		r1, argOk = args.Get(1).(error)
		if !argOk {
			panic("incorrect type supplied for return value [1], expected error")
		}
	}
	return r0, r1
}
`

	ret, err := writeMock(templateData, NewFileWriter(), "test_mock.go")
	assert.NoError(t, err)
	assert.Equal(t, expectedFile, string(ret))
}
