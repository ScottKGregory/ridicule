package main

import (
	"fmt"
	"go/parser"
	"go/token"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestParse(t *testing.T) {
	testFileSrc := `package foo

	import (
		name "github.com/scottkgregory/name"
		"github.com/scottkgregory/gen"
	)

	type X interface {
		Flavour() string
	}

	type Y[T any] interface {
		X
		Name() name.Name
		YYY(x int, y string, b bool) (int, error)
		ZZZ(x *int) (int, error)
		AAAA(x *int) (length *int, err error)
		BBBB(x map[string]*int) (length *int, err error)
		CCCC(x []name.Name) (length *int, err error)
		DDDD(x ...name.Name) (length *int, err error)
		EEEE(x func(y int, z string) error) (length *int, err error)
		FFFF(y T) error
		GGGG(y T) map[string]T
		HHHH(y T) gen.Generic[name.Name, string]
	}
	`

	expectedData := &TemplateData{
		Package: "foo",
		Interfaces: []*Interface{
			{
				Name:     "X",
				MockName: "",
				Funcs: []*Func{
					{
						Name: "Flavour",
						Return: []*Param{
							{Name: "", Type: "string"},
						},
					},
				},
			},
			{
				Name:     "Y",
				MockName: "",
				Funcs: []*Func{
					{
						Name: "Name",
						Return: []*Param{
							{Name: "", Type: "name.Name"},
						},
					},
					{
						Name: "YYY",
						Params: []*Param{
							{Name: "x", Type: "int"},
							{Name: "y", Type: "string"},
							{Name: "b", Type: "bool"},
						},
						Return: []*Param{
							{Name: "", Type: "int"},
							{Name: "", Type: "error"},
						},
					},
					{
						Name: "ZZZ",
						Params: []*Param{
							{Name: "x", Type: "*int"},
						},
						Return: []*Param{
							{Name: "", Type: "int"},
							{Name: "", Type: "error"},
						},
					},
					{
						Name: "AAAA",
						Params: []*Param{
							{Name: "x", Type: "*int"},
						},
						Return: []*Param{
							{Name: "length", Type: "*int"},
							{Name: "err", Type: "error"},
						},
					},
					{
						Name: "BBBB",
						Params: []*Param{
							{Name: "x", Type: "map[string]*int"},
						},
						Return: []*Param{
							{Name: "length", Type: "*int"},
							{Name: "err", Type: "error"},
						},
					},
					{
						Name: "CCCC",
						Params: []*Param{
							{Name: "x", Type: "[]name.Name"},
						},
						Return: []*Param{
							{Name: "length", Type: "*int"},
							{Name: "err", Type: "error"},
						},
					},
					{
						Name: "DDDD",
						Params: []*Param{
							{Name: "x", Type: "...name.Name"},
						},
						Return: []*Param{
							{Name: "length", Type: "*int"},
							{Name: "err", Type: "error"},
						},
					},
					{
						Name: "EEEE",
						Params: []*Param{
							{Name: "x", Type: "func(int, string) error"},
						},
						Return: []*Param{
							{Name: "length", Type: "*int"},
							{Name: "err", Type: "error"},
						},
					},
					{
						Name: "FFFF",
						Params: []*Param{
							{Name: "y", Type: "T"},
						},
						Return: []*Param{
							{Name: "", Type: "error"},
						},
					},
					{
						Name: "GGGG",
						Params: []*Param{
							{Name: "y", Type: "T"},
						},
						Return: []*Param{
							{Name: "", Type: "map[string]T"},
						},
					},
					{
						Name: "HHHH",
						Params: []*Param{
							{Name: "y", Type: "T"},
						},
						Return: []*Param{
							{Name: "", Type: "gen.Generic[name.Name, string]"},
						},
					},
				},
				Generics: []*Param{
					{Name: "T", Type: "any"},
				},
				Embedded: []string{"MockX"},
			},
		},
		Imports: []string{"name \"github.com/scottkgregory/name\"", "\"github.com/scottkgregory/gen\""},
		Header:  false,
	}

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "", testFileSrc, parser.ParseComments)
	if err != nil {
		fmt.Printf("error: parsing file: %s\n", err)
		return
	}

	templateData := Parse(f)
	assert.Equal(t, expectedData, templateData)

	templateData.Header = true
	expectedFile := `// Code generated by 'ridicule' DO NOT EDIT.
//
// ######   #####     ######   #####  #######    ####### ######  ####### #######
// ####### #######    ####### ####### #######    ####### ####### ####### #######
// ### ### ### ###    ### ### ### ###   ###      ###     ### ###   ###     ###
// ### ### ### ###    ### ### ### ###   ###      ####### ### ###   ###     ###
// ### ### ### ###    ### ### ### ###   ###      ###     ### ###   ###     ###
// ####### #######    ### ### #######   ###      ####### ####### #######   ###
// ######   #####     ### ###  #####    ###      ####### ######  #######   ###
//
// *** DO NOT EDIT *** This file was generated by 'ridicule' *** DO NOT EDIT ***

package foo

import (
	"github.com/scottkgregory/gen"
	name "github.com/scottkgregory/name"
	"github.com/stretchr/testify/mock"
)

// MockX mocks the X interface
type MockX struct {
	mock.Mock
}

// MockY mocks the Y interface
type MockY[T any] struct {
	mock.Mock
	MockX
}

// Flavour mocks the Flavour function
func (mock *MockX) Flavour() (r0 string) {
	args := mock.Called()

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(string)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected string")
		}
	}
	return r0
}

// Name mocks the Name function
func (mock *MockY[T]) Name() (r0 name.Name) {
	args := mock.Called()

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(name.Name)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected name.Name")
		}
	}
	return r0
}

// YYY mocks the YYY function
func (mock *MockY[T]) YYY(x int, y string, b bool) (r0 int, r1 error) {
	args := mock.Called(x, y, b)

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(int)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected int")
		}
	}

	if args.Get(1) != nil {
		argOk := false
		r1, argOk = args.Get(1).(error)
		if !argOk {
			panic("incorrect type supplied for return value [1], expected error")
		}
	}
	return r0, r1
}

// ZZZ mocks the ZZZ function
func (mock *MockY[T]) ZZZ(x *int) (r0 int, r1 error) {
	args := mock.Called(x)

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(int)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected int")
		}
	}

	if args.Get(1) != nil {
		argOk := false
		r1, argOk = args.Get(1).(error)
		if !argOk {
			panic("incorrect type supplied for return value [1], expected error")
		}
	}
	return r0, r1
}

// AAAA mocks the AAAA function
func (mock *MockY[T]) AAAA(x *int) (r0 *int, r1 error) {
	args := mock.Called(x)

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(*int)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected *int")
		}
	}

	if args.Get(1) != nil {
		argOk := false
		r1, argOk = args.Get(1).(error)
		if !argOk {
			panic("incorrect type supplied for return value [1], expected error")
		}
	}
	return r0, r1
}

// BBBB mocks the BBBB function
func (mock *MockY[T]) BBBB(x map[string]*int) (r0 *int, r1 error) {
	args := mock.Called(x)

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(*int)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected *int")
		}
	}

	if args.Get(1) != nil {
		argOk := false
		r1, argOk = args.Get(1).(error)
		if !argOk {
			panic("incorrect type supplied for return value [1], expected error")
		}
	}
	return r0, r1
}

// CCCC mocks the CCCC function
func (mock *MockY[T]) CCCC(x []name.Name) (r0 *int, r1 error) {
	args := mock.Called(x)

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(*int)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected *int")
		}
	}

	if args.Get(1) != nil {
		argOk := false
		r1, argOk = args.Get(1).(error)
		if !argOk {
			panic("incorrect type supplied for return value [1], expected error")
		}
	}
	return r0, r1
}

// DDDD mocks the DDDD function
func (mock *MockY[T]) DDDD(x ...name.Name) (r0 *int, r1 error) {
	args := mock.Called(x)

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(*int)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected *int")
		}
	}

	if args.Get(1) != nil {
		argOk := false
		r1, argOk = args.Get(1).(error)
		if !argOk {
			panic("incorrect type supplied for return value [1], expected error")
		}
	}
	return r0, r1
}

// EEEE mocks the EEEE function
func (mock *MockY[T]) EEEE(x func(int, string) error) (r0 *int, r1 error) {
	args := mock.Called(x)

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(*int)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected *int")
		}
	}

	if args.Get(1) != nil {
		argOk := false
		r1, argOk = args.Get(1).(error)
		if !argOk {
			panic("incorrect type supplied for return value [1], expected error")
		}
	}
	return r0, r1
}

// FFFF mocks the FFFF function
func (mock *MockY[T]) FFFF(y T) (r0 error) {
	args := mock.Called(y)

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(error)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected error")
		}
	}
	return r0
}

// GGGG mocks the GGGG function
func (mock *MockY[T]) GGGG(y T) (r0 map[string]T) {
	args := mock.Called(y)

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(map[string]T)
		if !argOk {
			panic("incorrect type supplied for return value [0], expected map[string]T")
		}
	}
	return r0
}

// HHHH mocks the HHHH function
func (mock *MockY[T]) HHHH(y T) (r0 gen.Generic[name.Name, string]) {
	args := mock.Called(y)

	if args.Get(0) != nil {
		argOk := false
		r0, argOk = args.Get(0).(gen.Generic[name.Name, string])
		if !argOk {
			panic("incorrect type supplied for return value [0], expected gen.Generic[name.Name, string]")
		}
	}
	return r0
}
`

	ret, err := writeMock(templateData, NewFileWriter(), "test_mock.go")
	assert.NoError(t, err)
	assert.Equal(t, expectedFile, string(ret))
}
